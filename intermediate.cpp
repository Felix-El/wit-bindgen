// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!

// Ensure that the *_component_type.o object is linked in
#ifdef __wasm32__
extern void __component_type_object_force_link_intermediate(void);
void __component_type_object_force_link_intermediate_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_intermediate();
}
#endif
#include "intermediate_cpp.h"
#include <cstdlib> // realloc

extern "C" void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size);

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}


extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("string-error")))
void testX3AresultsX2FtestX00string_error(float, uint8_t *);
extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("enum-error")))
void testX3AresultsX2FtestX00enum_error(float, uint8_t *);
extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("record-error")))
void testX3AresultsX2FtestX00record_error(float, uint8_t *);
extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("variant-error")))
void testX3AresultsX2FtestX00variant_error(float, uint8_t *);
extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("empty-error")))
void testX3AresultsX2FtestX00empty_error(int32_t, uint8_t *);
extern "C" __attribute__((import_module("test:results/test")))
__attribute__((import_name("double-error")))
void testX3AresultsX2FtestX00double_error(int32_t, uint8_t *);
std::expected<float, wit::string> test::results::test::StringError(float a)
{
  uintptr_t ret_area[((3*sizeof(void*))+sizeof(uintptr_t)-1)/sizeof(uintptr_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00string_error((float(a)), ptr0);
  std::expected<float, wit::string> result2;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    
    result2.emplace((float(*((float*) (ptr0 + sizeof(void*))))));
  } else {
    auto len1 = *((size_t*) (ptr0 + (2*sizeof(void*))));


    result2=std::unexpected{wit::string((char const*)(*((uint8_t**) (ptr0 + sizeof(void*)))), len1)};
  }
  auto result3 = result2;
  return result3;
}
std::expected<float, test::results::test::E> test::results::test::EnumError(float a)
{
  uint32_t ret_area[(8+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00enum_error((float(a)), ptr0);
  std::expected<float, E> result1;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    
    result1.emplace((float(*((float*) (ptr0 + 4)))));
  } else {
    
    result1=std::unexpected{(E)(int32_t) (*((uint8_t*) (ptr0 + 4)))};
  }
  auto result2 = result1;
  return result2;
}
std::expected<float, test::results::test::E2> test::results::test::RecordError(float a)
{
  uint32_t ret_area[(12+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00record_error((float(a)), ptr0);
  std::expected<float, E2> result3;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    
    result3.emplace((float(*((float*) (ptr0 + 4)))));
  } else {
    int32_t l1 = *((int32_t const*)(ptr0 + 4));
    int32_t l2 = *((int32_t const*)(ptr0 + 8));

    result3=std::unexpected{E2{(uint32_t(l1)), (uint32_t(l2)), }};
  }
  auto result4 = result3;
  return result4;
}
std::expected<float, test::results::test::E3> test::results::test::VariantError(float a)
{
  uint32_t ret_area[(16+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00variant_error((float(a)), ptr0);
  std::expected<float, E3> result3;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    float l1 = *((float const*)(ptr0 + 4));
    result3.emplace(l1);
  } else {
    switch (*((uint8_t const*)(ptr0 + 4))) {
      case 0: {
        result3 = std::unexpected{E3{std::variant<E3::E1, E3::E2>(E3::E1{E(*(const uint8_t*)(ptr0 + 8))})}};
        break;
      }
      case 1: {
        uint32_t l1 = *((uint32_t const*)(ptr0 + 8));
        uint32_t l2 = *((uint32_t const*)(ptr0 + 12));
        result3 = std::unexpected{E3{std::variant<E3::E1, E3::E2>(E3::E2{test::E2{l1,l2}})}};
        break; 
      }
    }
  }
  auto result4 = std::move(result3);
  return result4;
}
std::expected<uint32_t, wit::Void> test::results::test::EmptyError(uint32_t a)
{
  uint32_t ret_area[(8+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00empty_error((int32_t(a)), ptr0);
  std::expected<uint32_t, wit::Void> result2;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    int32_t l1 = *((int32_t const*)(ptr0 + 4));

    result2.emplace((uint32_t(l1)));
  } else {
    
    result2=std::unexpected{wit::Void{}};
  }
  auto result3 = result2;
  return result3;
}
std::expected<std::expected<void, wit::string>, wit::string> test::results::test::DoubleError(uint32_t a)
{
  uintptr_t ret_area[((4*sizeof(void*))+sizeof(uintptr_t)-1)/sizeof(uintptr_t)];
  uint8_t* ptr0 = (uint8_t*)(&ret_area);
  testX3AresultsX2FtestX00double_error((int32_t(a)), ptr0);
  std::expected<std::expected<void, wit::string>, wit::string> result4;
  if ((int32_t) (*((uint8_t*) (ptr0 + 0)))==0) {
    std::expected<void, wit::string> result2;
    if ((int32_t) (*((uint8_t*) (ptr0 + sizeof(void*))))==0) {
      
      
    } else {
      auto len1 = *((size_t*) (ptr0 + (3*sizeof(void*))));


      result2=std::unexpected{wit::string((char const*)(*((uint8_t**) (ptr0 + (2*sizeof(void*))))), len1)};
    }

    result4.emplace(std::move(result2));
  } else {
    auto len3 = *((size_t*) (ptr0 + (2*sizeof(void*))));


    result4=std::unexpected{wit::string((char const*)(*((uint8_t**) (ptr0 + sizeof(void*)))), len3)};
  }
  auto result5 = result4;
  return result5;
}
extern "C" __attribute__((__export_name__("test:results/test#string-error")))
uint8_t * testX3AresultsX2FtestX23string_error(float arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::StringError((float(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uintptr_t ret_area[((3*sizeof(void*))+sizeof(uintptr_t)-1)/sizeof(uintptr_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    float payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    *((float*)(ptr1 + sizeof(void*))) = (float(payload2));
  } else {
    wit::string payload3 = std::move(result0).error();
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
    auto const&vec4 = payload3;
    auto ptr4 = (uint8_t*)(vec4.data());
    auto len4 = (size_t)(vec4.size());
    payload3.leak();

    *((size_t*)(ptr1 + (2*sizeof(void*)))) = len4;
    *((uint8_t**)(ptr1 + sizeof(void*))) = ptr4;
  }
  return ptr1;
}
extern "C" __attribute__((__weak__, __export_name__("cabi_post_test:results/test#string-error")))
void cabi_post_testX3AresultsX2FtestX23string_error(uint8_t * arg0) {
  switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + 0)))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        wit::string::drop_raw((void*) (*((uint8_t**) (arg0 + sizeof(void*)))));
      }
      break;
    }
  }
}
extern "C" __attribute__((__export_name__("test:results/test#enum-error")))
uint8_t * testX3AresultsX2FtestX23enum_error(float arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::EnumError((float(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uint32_t ret_area[(8+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    float payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    *((float*)(ptr1 + 4)) = (float(payload2));
  } else {
    test::results::test::E payload3 = std::move(result0).error();
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
    *((int8_t*)(ptr1 + 4)) = int32_t(payload3);
  }
  return ptr1;
}
extern "C" __attribute__((__export_name__("test:results/test#record-error")))
uint8_t * testX3AresultsX2FtestX23record_error(float arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::RecordError((float(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uint32_t ret_area[(12+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    float payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    *((float*)(ptr1 + 4)) = (float(payload2));
  } else {
    test::results::test::E2 payload3 = std::move(result0).error();
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
    *((int32_t*)(ptr1 + 4)) = (int32_t((payload3).line));
    *((int32_t*)(ptr1 + 8)) = (int32_t((payload3).column));
  }
  return ptr1;
}
extern "C" __attribute__((__export_name__("test:results/test#variant-error")))
uint8_t * testX3AresultsX2FtestX23variant_error(float arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::VariantError((float(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uint32_t ret_area[(16+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    float payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    *((float*)(ptr1 + 4)) = (float(payload2));
  } else {
    test::results::test::E3 payload3 = std::move(result0).error();
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
    switch ((int32_t) (payload3).variants.index()) {
      case 0: {
        const test::results::test::E &payload4 = std::get<test::results::test::E3::E1>(payload3.variants).value;
        *((int8_t*)(ptr1 + 4)) = (int32_t(0));
        *((int8_t*)(ptr1 + 8)) = int32_t(payload4);
        break;
      }
      case 1: {
        const test::results::test::E2 &payload5 = std::get<test::results::test::E3::E2>(payload3.variants).value;
        *((int8_t*)(ptr1 + 4)) = (int32_t(1));
        *((int32_t*)(ptr1 + 8)) = (int32_t((payload5).line));
        *((int32_t*)(ptr1 + 12)) = (int32_t((payload5).column));
        break;
      }
    }
  }
  return ptr1;
}
extern "C" __attribute__((__export_name__("test:results/test#empty-error")))
uint8_t * testX3AresultsX2FtestX23empty_error(int32_t arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::EmptyError((uint32_t(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uint32_t ret_area[(8+sizeof(uint32_t)-1)/sizeof(uint32_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    uint32_t payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    *((int32_t*)(ptr1 + 4)) = (int32_t(payload2));
  } else {
    
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
  }
  return ptr1;
}
extern "C" __attribute__((__export_name__("test:results/test#double-error")))
uint8_t * testX3AresultsX2FtestX23double_error(int32_t arg0)
{
  std::vector<void*> _deallocate;
  auto result0 = exports::test::results::test::DoubleError((uint32_t(arg0)));
  for (auto i: _deallocate) { free(i); }

  _deallocate.clear();
  static uintptr_t ret_area[((4*sizeof(void*))+sizeof(uintptr_t)-1)/sizeof(uintptr_t)];
  uint8_t* ptr1 = (uint8_t*)(&ret_area);
  if ((result0).has_value()) {
    std::expected<void, wit::string> payload2 = std::move(result0).value();
    *((int8_t*)(ptr1 + 0)) = (int32_t(0));
    if ((payload2).has_value()) {
      
      *((int8_t*)(ptr1 + sizeof(void*))) = (int32_t(0));
    } else {
      wit::string payload4 = std::move(payload2).error();
      *((int8_t*)(ptr1 + sizeof(void*))) = (int32_t(1));
      auto const&vec5 = payload4;
      auto ptr5 = (uint8_t*)(vec5.data());
      auto len5 = (size_t)(vec5.size());
      payload4.leak();

      *((size_t*)(ptr1 + (3*sizeof(void*)))) = len5;
      *((uint8_t**)(ptr1 + (2*sizeof(void*)))) = ptr5;
    }
  } else {
    wit::string payload6 = std::move(result0).error();
    *((int8_t*)(ptr1 + 0)) = (int32_t(1));
    auto const&vec7 = payload6;
    auto ptr7 = (uint8_t*)(vec7.data());
    auto len7 = (size_t)(vec7.size());
    payload6.leak();

    *((size_t*)(ptr1 + (2*sizeof(void*)))) = len7;
    *((uint8_t**)(ptr1 + sizeof(void*))) = ptr7;
  }
  return ptr1;
}
extern "C" __attribute__((__weak__, __export_name__("cabi_post_test:results/test#double-error")))
void cabi_post_testX3AresultsX2FtestX23double_error(uint8_t * arg0) {
  switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + 0)))) {
    case 0: {
      switch ((int32_t) (int32_t) (*((uint8_t*) (arg0 + sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (3*sizeof(void*))))) > 0) {
            wit::string::drop_raw((void*) (*((uint8_t**) (arg0 + (2*sizeof(void*))))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (2*sizeof(void*))))) > 0) {
        wit::string::drop_raw((void*) (*((uint8_t**) (arg0 + sizeof(void*)))));
      }
      break;
    }
  }
}

// Component Adapters
