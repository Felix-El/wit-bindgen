use futures::{task::Waker, FutureExt};
use std::{
    future::Future,
    mem::MaybeUninit,
    pin::Pin,
    sync::{Arc, RwLock},
    task::{Context, Poll, RawWaker, RawWakerVTable},
};

use crate::module::symmetric::runtime::symmetric_executor::{
    self, CallbackState, EventGenerator, EventSubscription,
};

pub use future_support::{FutureReader, FutureVtable, FutureWriter};
pub use stream_support::{
    results, stream_new, Stream, StreamReader, StreamResult, StreamVtable, StreamWriter,
};
pub use subtask::Subtask;

pub mod future_support;
// later make it non-pub
pub mod stream_support;
mod subtask;

// See https://github.com/rust-lang/rust/issues/13231 for the limitation
// / Send constraint on futures for spawn, loosen later
// pub unsafe auto trait MaybeSend : Send {}
// unsafe impl<T> MaybeSend for T where T: Send {}

type BoxFuture = Pin<Box<dyn Future<Output = ()> + 'static>>;

struct FutureState {
    future: BoxFuture,
    // signal to activate once the current async future has finished
    completion_event: Option<EventGenerator>,
    // the event this future should wake on
    waiting_for: Option<EventSubscription>,
}

static VTABLE: RawWakerVTable = RawWakerVTable::new(
    |_| RawWaker::new(core::ptr::null(), &VTABLE),
    // `wake` does nothing
    |_| {},
    // `wake_by_ref` does nothing
    |_| {},
    // Dropping does nothing as we don't allocate anything
    |_| {},
);

pub fn new_waker(waiting_for_ptr: *mut Option<EventSubscription>) -> Waker {
    unsafe { Waker::from_raw(RawWaker::new(waiting_for_ptr.cast(), &VTABLE)) }
}

unsafe fn poll(state: *mut FutureState) -> Poll<()> {
    let mut pinned = std::pin::pin!(&mut (*state).future);
    let waker = new_waker(&mut (&mut *state).waiting_for as *mut Option<EventSubscription>);
    pinned
        .as_mut()
        .poll(&mut Context::from_waker(&waker))
        .map(|()| {
            let state_owned = Box::from_raw(state);
            if let Some(waker) = &state_owned.completion_event {
                waker.activate();
            }
            drop(state_owned);
        })
}

pub async fn wait_on(wait_for: EventSubscription) {
    std::future::poll_fn(move |cx| {
        if wait_for.ready() {
            Poll::Ready(())
        } else {
            // remember this eventsubscription in the context
            let data = cx.waker().data();
            let mut copy = Some(wait_for.dup());
            std::mem::swap(
                unsafe { &mut *(data.cast::<Option<EventSubscription>>().cast_mut()) },
                &mut copy,
            );
            Poll::Pending
        }
    })
    .await
}

extern "C" fn symmetric_callback(obj: *mut ()) -> CallbackState {
    match unsafe { poll(obj.cast()) } {
        Poll::Ready(_) => CallbackState::Ready,
        Poll::Pending => {
            let state = obj.cast::<FutureState>();
            if let Some(waiting_for) = unsafe { &mut *state }.waiting_for.take() {
                super::register(waiting_for, symmetric_callback, obj);
            }
            // as we registered this callback on a new event stop calling
            // from the old event
            CallbackState::Ready
        }
    }
}

pub fn first_poll_sub(future: BoxFuture) -> *mut () {
    let state = Box::into_raw(Box::new(FutureState {
        future,
        completion_event: None,
        waiting_for: None,
    }));
    match unsafe { poll(state) } {
        Poll::Ready(()) => core::ptr::null_mut(),
        Poll::Pending => {
            if let Some(waiting_for) = unsafe { &mut *state }.waiting_for.take() {
                let completion_event = EventGenerator::new();
                let wait_chain = completion_event.subscribe().take_handle() as *mut ();
                unsafe { &mut *state }
                    .completion_event
                    .replace(completion_event);
                super::register(waiting_for, symmetric_callback, state.cast());
                wait_chain
            } else {
                core::ptr::null_mut()
            }
        }
    }
}

/// Poll the future generated by a call to an async-lifted export once, calling
/// the specified closure (presumably backed by a call to `task.return`) when it
/// generates a value.
///
/// This will return a non-null pointer representing the task if it hasn't
/// completed immediately; otherwise it returns null.
#[doc(hidden)]
pub fn first_poll<T: 'static>(
    future: impl Future<Output = T> + 'static,
    fun: impl FnOnce(T) + 'static,
) -> *mut () {
    first_poll_sub(Box::pin(future.map(fun)))
}

/// Await the completion of a call to an async-lowered import.
#[doc(hidden)]
pub async unsafe fn await_result(function: impl Fn() -> *mut u8) {
    let wait_for = function();
    if !wait_for.is_null() {
        let wait_for = unsafe { EventSubscription::from_handle(wait_for as usize) };
        wait_on(wait_for).await;
    }
}

pub fn spawn(future: impl Future<Output = ()> + 'static + Send) {
    let wait_for = first_poll(future, |()| ());
    let wait_for = unsafe { EventSubscription::from_handle(wait_for as usize) };
    drop(wait_for);
}

pub unsafe fn spawn_unchecked(future: impl Future<Output = ()>) {
    let future1: Pin<Box<dyn Future<Output = ()>>> = Box::pin(future);
    let wait_for = first_poll_sub(unsafe { std::mem::transmute(future1) });
    if !wait_for.is_null() {
        let wait_for = unsafe { EventSubscription::from_handle(wait_for as usize) };
        drop(wait_for);
    }
}

pub fn block_on<T: 'static>(future: impl Future<Output = T> + 'static) -> T {
    // ugly but might do the trick
    let result: Arc<RwLock<MaybeUninit<T>>> = Arc::new(RwLock::new(MaybeUninit::uninit()));
    let result2 = Arc::clone(&result);
    let future2 = async move {
        result2.write().unwrap().write(future.await);
    };
    unsafe { spawn_unchecked(future2) };
    symmetric_executor::run();
    return unsafe { result.to_owned().write().unwrap().assume_init_read() };
}
